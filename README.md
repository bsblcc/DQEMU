DQEMU
这个项目想把跨体系结构的不同物理机器组成一个有中心的分布式系统, 以线程为调度单位, 并行运行同样的程序. 具体实现是以QEMU为基础, 改写一个分布式的QEMU版本.

我的工作主要有几部分, 一是设计并实现了DQEMU的程序架构: 包含一个center/master, 和许多workers/slaves. worker节点上有两个线程, 一个负责执行目标代码, 另一个负责与center通信, 实现cache coherence protocol, 二者通过pthread同步; server节点也有两类线程, 一个初始线程负责启动目标程序. 另外对于每个worker, 都有一个代理节点, 负责通信, 接受系统调用请求, 并且维护coherence等等.

二是新线程的创建部分. 当初始线程执行到了特定一类fork系统调用, 就表明目标程序试图建立新线程. 新线程要分配到一个worker节点上, 主要需要传递qemu中的context, 包括cpu的状态, 内存各个段的映射, 内容和权限等等.

三是要实现各个节点内存的coherence protocol, 类似缓存的MESI协议, 但不同点是DQEMU中没有唯一"内存"的概念, 各个页面的最新内容分散在各个worker上. cente处会维护一个目录, 对于每一个页面, 记录当前哪些worker拥有它的最新copy, 这些worker在本地都会拥有对该页面的相应权限. 当worker对一个页面进行读写, 但却无权限时, 会触发段错误. 它会在段错误的handler中与center通信, 发出一个request. center收到后会根据具体请求类型修改目录.
比如一个情况是 worker要写一个页面, 触发了段错误, server收到request后, 查看目录, 通知该页面的所有拥有者取消本地的权限, 这些拥有者会发回该页面的内容以回应, 当center收集到了所有人的回应, 就会把最初的请求者修改为唯一的拥有者, 并回复它内面内容. 这样最初的请求者就事实上有了该页面的exclusive权限.

四是简单地实现了原子指令. 发现原始的QEMU会将原子指令翻译成一段简单指令序列, 所以只要在这段序列的开头和结尾处通知center, 让这段时间内暂不响应其他worker对该页面的申请即可. 实现是通过代理节点在center处上锁.
